#!/usr/bin/perl
# This script has been build to run the tests in the bin directory.
use Getopt::Long;
use List::Util qw(shuffle);
use strict;

##Parse Args
my $verbose = '';	# option variable with default value (false)
my $writer_prog = "bin/TestSstServer";
my $reader_prog = "bin/TestSstClient";
my $writer_args = "";
my $reader_args = "";
my $num_writers = 3;
my $num_readers = 2;
my $max_readers = 3;
my $test_protocol = 'kill_readers';
my $duration = 60;
my $interval = 5;
my $exit_value = 0;

GetOptions ('verbose!' => \$verbose, 
	    'writer=s' => \$writer_prog,
	    'reader=s' => \$reader_prog,
	    'warg=s@' => \$writer_args,
	    'rarg=s@' => \$reader_args,
	    'nw=i' => \$num_writers,
	    'nr=i' => \$num_readers,
	    'duration=i' => \$duration,
	    'interval=i' => \$interval,
	    'max_readers=i' => \$num_readers,
	    'test_protocol=s' => \$test_protocol)
  or die("Error in command line arguments\n");


my $writer_output = "";
my $reader_output = "";
my $result = 1;

defined(my $writer_pid = fork) or die "Cannot fork $!";
unless($writer_pid)
  {
    #Child process is here
    exec ("mpirun -n $num_writers ./$writer_prog --duration $duration $writer_args");
    die "Can't exec mpirun! $!";
  }
print "Writer PID: $writer_pid\n" if $verbose;
        

if ($test_protocol == "kill_readers") {
  
  my @ReaderPIDs;
  print "Duration at beginning is $duration\n" if $verbose;
  while ($duration > 0) {
    my $r = rand();
    print "Start, number of readers is $#ReaderPIDs\n" if $verbose;
    if ((($#ReaderPIDs <= 0) || ($r < 0.5))  && ($#ReaderPIDs != $max_readers)){
      # fork a reader
      defined(my $reader_pid = fork) or die "Cannot fork $!";
      unless($reader_pid)
	{
	  #Child process is here
	  print "EXEC $reader_prog\n" if $verbose;
	  exec ("mpirun -n $num_readers $reader_prog $reader_args");
	  die "Can't exec mpirun! $!";
	}
      print "Reader PID: $reader_pid\n" if $verbose;
      push @ReaderPIDs, $reader_pid;
    } else {
      # kill a reader 
      my $readerToKill;
      @ReaderPIDs = shuffle @ReaderPIDs;
      my $readerToKill = shift @ReaderPIDs;
      kill 'KILL', $readerToKill;
      print "KILLED Reader PID: $readerToKill\n" if $verbose;
      waitpid($readerToKill, 0);
      print "Status of killed reader was $?\n" if $verbose;
      if (($? != 0) || ($? != 9)) {
	$exit_value = 1; #failure
	print "Setting failure return because of bad exit status of killed reader\n";
      }
    }
    sleep $interval;
    $duration -= $interval;
    print "Duration is now $duration\n" if $verbose;
  }
  foreach my $readerPID (@ReaderPIDs) {
      waitpid($readerPID, 0);
      print "Status of final reader was $?\n" if $verbose;
      if ($? != 0) {
	$exit_value = 1; #failure
	print "Setting failure return because of bad exit status on normal reader\n";
      }
  }    
  waitpid($writer_pid, 0);
  print "Status of writer was $?\n" if $verbose;
  if ($? != 0) {
    $exit_value = 1; #failure
    print "Setting failure return because of bad exit status of writer\n";
  }
  exit $exit_value;
} # end kill_readers protocol

