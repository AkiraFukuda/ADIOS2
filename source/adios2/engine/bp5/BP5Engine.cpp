/*
 * Distributed under the OSI-approved Apache License, Version 2.0.  See
 * accompanying file Copyright.txt for details.
 *
 * BP5Engine.cpp
 *
 */

#include "BP5Engine.h"

#include "adios2/common/ADIOSMacros.h"
#include "adios2/common/ADIOSTypes.h" //PathSeparator
#include "adios2/core/IO.h"
#include "adios2/helper/adiosFunctions.h" //CreateDirectory, StringToTimeUnit,

#include <ctime>
#include <iostream>

namespace adios2
{
namespace core
{
namespace engine
{

std::vector<std::string>
BP5Engine::GetBPMetadataFileNames(const std::vector<std::string> &names) const
    noexcept
{
    std::vector<std::string> metadataFileNames;
    metadataFileNames.reserve(names.size());
    for (const auto &name : names)
    {
        metadataFileNames.push_back(GetBPMetadataFileName(name));
    }
    return metadataFileNames;
}

std::vector<std::string> BP5Engine::GetBPMetaMetadataFileNames(
    const std::vector<std::string> &names) const noexcept
{
    std::vector<std::string> metaMetadataFileNames;
    metaMetadataFileNames.reserve(names.size());
    for (const auto &name : names)
    {
        metaMetadataFileNames.push_back(GetBPMetaMetadataFileName(name));
    }
    return metaMetadataFileNames;
}

std::string BP5Engine::GetBPMetadataFileName(const std::string &name) const
    noexcept
{
    const std::string bpName = helper::RemoveTrailingSlash(name);
    const size_t index = 0; // global metadata file is generated by rank 0
    /* the name of the metadata file is "md.0" */
    const std::string bpMetaDataRankName(bpName + PathSeparator + "md." +
                                         std::to_string(index));
    return bpMetaDataRankName;
}

std::string BP5Engine::GetBPMetaMetadataFileName(const std::string &name) const
    noexcept
{
    const std::string bpName = helper::RemoveTrailingSlash(name);
    const size_t index = 0; // global metadata file is generated by rank 0
    /* the name of the metadata file is "md.0" */
    const std::string bpMetaMetaDataRankName(bpName + PathSeparator + "mmd." +
                                             std::to_string(index));
    return bpMetaMetaDataRankName;
}

std::vector<std::string> BP5Engine::GetBPMetadataIndexFileNames(
    const std::vector<std::string> &names) const noexcept
{
    std::vector<std::string> metadataIndexFileNames;
    metadataIndexFileNames.reserve(names.size());
    for (const auto &name : names)
    {
        metadataIndexFileNames.push_back(GetBPMetadataIndexFileName(name));
    }
    return metadataIndexFileNames;
}

std::string BP5Engine::GetBPMetadataIndexFileName(const std::string &name) const
    noexcept
{
    const std::string bpName = helper::RemoveTrailingSlash(name);
    /* the name of the metadata index file is "md.idx" */
    const std::string bpMetaDataIndexRankName(bpName + PathSeparator +
                                              "md.idx");
    return bpMetaDataIndexRankName;
}

std::string BP5Engine::GetBPSubStreamName(const std::string &name,
                                          const size_t id,
                                          const bool hasSubFiles,
                                          const bool isReader) const noexcept
{
    if (!hasSubFiles)
    {
        return name;
    }

    const std::string bpName = helper::RemoveTrailingSlash(name);

    const size_t index = id;
    //    isReader ? id
    //	: m_Aggregator.m_IsActive ? m_Aggregator.m_SubStreamIndex : id;

    /* the name of a data file starts with "data." */
    const std::string bpRankName(bpName + PathSeparator + "data." +
                                 std::to_string(index));
    return bpRankName;
}

std::vector<std::string>
BP5Engine::GetBPSubStreamNames(const std::vector<std::string> &names) const
    noexcept
{
    std::vector<std::string> bpNames;
    bpNames.reserve(names.size());

    for (const auto &name : names)
    {
        bpNames.push_back(
            GetBPSubStreamName(name, static_cast<unsigned int>(m_RankMPI)));
    }
    return bpNames;
}

void BP5Engine::ParseParams(IO &io, struct BP5Params &Params)
{
    std::memset(&Params, 0, sizeof(Params));

    auto lf_SetBoolParameter = [&](const std::string key, bool &parameter,
                                   bool def) {
        auto itKey = io.m_Parameters.find(key);
        parameter = def;
        if (itKey != io.m_Parameters.end())
        {
            std::string value = itKey->second;
            std::transform(value.begin(), value.end(), value.begin(),
                           ::tolower);
            if (value == "yes" || value == "true" || value == "on")
            {
                parameter = true;
            }
            else if (value == "no" || value == "false" || value == "off")
            {
                parameter = false;
            }
            else
            {
                throw std::invalid_argument(
                    "ERROR: Unknown BP5 Boolean parameter \"" + value + "\"");
            }
        }
    };
    auto lf_SetIntParameter = [&](const std::string key, int &parameter,
                                  int def) {
        auto itKey = io.m_Parameters.find(key);
        parameter = def;
        if (itKey != io.m_Parameters.end())
        {
            parameter = std::stoi(itKey->second);
            return true;
        }
        return false;
    };

    // auto lf_SetStringParameter = [&](const std::string key,
    //                                  std::string &parameter, char *def) {
    //     std::cout << "Set String Param , key = " << key << std::endl;
    //     auto itKey = io.m_Parameters.find(key);
    //     if (itKey != io.m_Parameters.end())
    //     {
    //         parameter = (itKey->second).c_str();
    //         return true;
    //     }
    //     return false;
    // };

#define get_params(Param, Type, Typedecl, Default)                             \
    std::cout << "GetParam, Param = " << #Param << std::endl;                  \
    lf_Set##Type##Parameter(#Param, Params.Param, Default);
    BP5_FOREACH_PARAMETER_TYPE_4ARGS(get_params);
#undef get_params
};

} // namespace engine
} // namespace core
} // namespace adios2
